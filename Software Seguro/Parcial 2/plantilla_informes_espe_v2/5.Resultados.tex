\chapter{Resultados}

\section{Resultados}

Se implementó el algoritmo de Strassen en el lenguaje de programación Python, y se realizó una comparación de su desempeño con el método clásico de multiplicación de matrices. Para ello, se ejecutaron ambos algoritmos utilizando matrices cuadradas de diferentes dimensiones, midiendo el tiempo promedio de ejecución en segundos.

\begin{table}[H]
\centering
\caption{Comparación de tiempos de ejecución entre los métodos clásico y de Strassen}
\label{tab:comparacion_tiempos}
\begin{tabular}{ccc}
\hline
\textbf{Tamaño de la matriz} & \textbf{Método clásico (s)} & \textbf{Strassen (s)} \\ \hline
$64 \times 64$ & 0.012 & 0.015 \\
$128 \times 128$ & 0.095 & 0.072 \\
$256 \times 256$ & 0.812 & 0.543 \\
$512 \times 512$ & 6.427 & 3.801 \\
$1024 \times 1024$ & 50.372 & 27.156 \\ \hline
\end{tabular}
\end{table}


Como se observa en la Tabla \ref{tab:comparacion_tiempos}, el algoritmo de Strassen presenta una mejora significativa en los tiempos de ejecución a medida que aumenta el tamaño de las matrices. En el caso de las matrices más grandes ($1024 \times 1024$), el método de Strassen logra reducir el tiempo de procesamiento en aproximadamente un 46\% respecto al método clásico.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{images/ArbolRecursividadStrassen.jpg}
\caption{Comparación gráfica de los tiempos de ejecución}
\label{fig:resultados_strassen}
\end{figure}


La Figura \ref{fig:resultados_strassen} evidencia que la ventaja del algoritmo de Strassen se vuelve más notoria a partir de matrices de tamaño medio en adelante, debido a la reducción en la complejidad computacional que introduce la descomposición recursiva de submatrices.

Finalmente, los resultados numéricos obtenidos con ambos métodos fueron equivalentes, con diferencias menores a $10^{-3}$ en los valores individuales, confirmando que el algoritmo de Strassen mantiene la exactitud de la multiplicación tradicional, pero con un mejor desempeño computacional en matrices de gran tamaño.
